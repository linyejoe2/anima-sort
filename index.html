<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>anima-sort</title>
  <meta name="description" content="anima-sort help you visualizing sorting algorithms, includes some adjustable parameters.">
  <meta property="og:description" content="anima-sort help you visualizing sorting algorithms, includes some adjustable parameters.">
  <meta property="og:title" content="anima-sort">
  <meta property="og:url" content="https://linyejoe2.site/anima-sort/">
  <style>
    /* CSS */
    button {
      appearance: none;
      background-color: #FAFBFC;
      border: 1px solid rgba(27, 31, 35, 0.15);
      border-radius: 6px;
      box-shadow: rgba(27, 31, 35, 0.04) 0 1px 0, rgba(255, 255, 255, 0.25) 0 1px 0 inset;
      box-sizing: border-box;
      color: #24292E;
      cursor: pointer;
      display: inline-block;
      font-family: -apple-system, system-ui, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
      list-style: none;
      padding: 6px 16px;
      position: relative;
      transition: background-color 0.2s cubic-bezier(0.3, 0, 0.5, 1);
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      vertical-align: middle;
      white-space: nowrap;
      word-wrap: break-word;
    }

    button:hover {
      background-color: #F3F4F6;
      text-decoration: none;
      transition-duration: 0.1s;
    }

    button:disabled {
      background-color: #FAFBFC;
      border-color: rgba(27, 31, 35, 0.15);
      color: #959DA5;
      cursor: default;
    }

    button:active {
      background-color: #EDEFF2;
      box-shadow: rgba(225, 228, 232, 0.2) 0 1px 0 inset;
      transition: none 0s;
    }

    button:focus {
      outline: 1px transparent;
    }

    button:before {
      display: none;
    }

    button:-webkit-details-marker {
      display: none;
    }

    * {
      margin: 0px;
      padding: 0px;
      box-sizing: border-box;
      user-select: none;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      display: flex;
      /* justify-content: center;
      align-items: center; */
      height: 100vh;
    }

    .container {
      background-color: #fff;
      /* border-radius: 10px; */
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      padding: 20px 30px;
      max-width: 20dvw;
      width: 100%;
    }

    .container h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.5rem;
      color: #555;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
    }

    .form-group label {
      margin-bottom: 5px;
      font-weight: bold;
      color: #666;
    }

    .form-group input {
      padding: 10px;
      font-size: 1rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      transition: border-color 0.3s;
    }

    .form-group input:focus {
      border-color: #007bff;
      outline: none;
    }

    .button-group {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }

    .button-group button {
      padding: 10px 15px;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
    }

    .button-group button#pushShiftBtn {
      background-color: #007bff;
      color: #fff;
    }

    .button-group button#pushShiftBtn:hover {
      background-color: #0056b3;
    }

    .button-group button#resetBtn {
      background-color: #dc3545;
      color: #fff;
    }

    .button-group button#resetBtn:hover {
      background-color: #a71d2a;
    }

    .button-group button:active {
      transform: scale(0.98);
    }

    /* Styles for the sorting section */
    .sorting-section {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    .sort-column {
      flex: 1 1 calc(25% - 10px);
      margin: 0 5px 20px;
    }

    .sort-div {
      flex: 1 1 calc(25% - 10px);
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      background-color: #f8f9fa;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      transition: box-shadow 0.3s;
    }

    .sort-div:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .sort-button {
      background-color: #6c757d;
      color: #fff;
      padding: 8px 12px;
      font-size: 0.9rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
    }

    .sort-button:hover {
      background-color: #495057;
    }

    .sort-button:active {
      transform: scale(0.95);
    }

    label {
      font-size: 0.9rem;
      color: #555;
    }

    /* width */
    ::-webkit-scrollbar {
      width: 10px;
    }

    /* Track */
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    /* Handle */
    ::-webkit-scrollbar-thumb {
      border-radius: 20px;
      background: #888;
    }

    /* Handle on hover */
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* #parameter::-webkit-scrollbar {
      display: none;
    }

    #parameter {
      -ms-overflow-style: none;
      scrollbar-width: none;
    } */

    /* .sort-div {
      display: flex;
    }

    .sort-button {
      margin-right: 5px;
    } */
  </style>
</head>

<body>
  <div id="parameter" style="overflow: scroll;overflow-x: hidden;">
    <div class="container">
      <h1>Setting</h1>
      <div class="form-group">
        <label for="delay">Delay</label>
        <input id="delay" type="text" value="100">
      </div>
      <div class="form-group">
        <label for="numbersLowerBound">Numbers Lower Bound</label>
        <input id="numbersLowerBound" type="text" value="1">
      </div>
      <div class="form-group">
        <label for="numbersUpperBound">Numbers Upper Bound</label>
        <input id="numbersUpperBound" type="text" value="100">
      </div>
      <div class="form-group">
        <label for="numbersOfNumber">Numbers of Number</label>
        <input id="numbersOfNumber" type="text" value="25">
      </div>
      <div class="button-group">
        <button id="pushShiftBtn">Shift & Push</button>
        <button id="resetBtn">Reset</button>
      </div>

      <div class="sorting-section">
        <div class="sort-div">
          <button class="sort-button" id="bubbleSortBtn">Bubble sort</button>
          <label>Bubble sort use time: </label><label><span id="bubbleTime">0</span> s</label>
        </div>
        <div class="sort-div">
          <button class="sort-button" id="selectionSortBtn">Selection sort</button>
          <label>Selection sort use time: </label><label><span id="selectionTime">0</span> s</label>
        </div>
        <div class="sort-div">
          <button class="sort-button" id="insertionSortBtn">Insertion sort</button>
          <label>Insertion sort use time: </label><label><span id="insertionTime">0</span> s</label>
        </div>
        <div class="sort-div">
          <button class="sort-button" id="mergeSortBtn">Merge sort</button>
          <label>Merge sort use time: </label><label><span id="mergeTime">0</span> s</label>
        </div>
        <div class="sort-div">
          <button class="sort-button" id="quickSortBtn">Quick sort (TODO)</button>
          <label>Quick sort use time: </label><label><span id="quickTime">0</span> s</label>
        </div>
        <div class="sort-div">
          <button class="sort-button" id="quickSortInplaceBtn">Quick sort (inplace)</button>
          <label>Quick sort (inplace) use time: </label><label><span id="quickInplaceTime">0</span> s</label>
        </div>
        <div class="sort-div">
          <button class="sort-button" id="countingSortBtn">Counting sort</button>
          <label>Counting sort use time: </label><label><span id="countingTime">0</span> s</label>
        </div>
        <div class="sort-div">
          <button class="sort-button" id="bucketSortBtn">Bucket sort (TODO)</button>
          <label>Bucket sort use time: </label><label><span id="bucketTime">0</span> s</label>
        </div>
      </div>

    </div>
  </div>

  <div id="sortingDiv" style="height: 95dvh; width: 77dvw; margin-left: 22dvw; margin-top: 15dvh; position: absolute; bottom: 25px; z-index: -1;">
    <canvas id="sortingCanvas"></canvas>
  </div>

  <script>
    let numbers = []
    let numberObjectStruct = {
      priviousIndex: 0,
      count: 0,
      value: 0,
      color: "skyblue"
    }
    let secondNumberObjects = []
    let currentIndex = -1
    let secondIndex = -1
    let thirdIndex = -1
    let stopFlag = false
    let bubbleTime
    let selectionTime
    let insertionTime
    let mergeTime
    let mergeCombineIndex = 0
    let mergeCombineSize = 0
    let quickInplaceTime
    let countingTime
    let bucketTime
    let delayMs = parseInt(document.getElementById("delay").value)
    let numbersOfNumber = parseInt(document.getElementById("numbersOfNumber").value)
    let upperBound = parseInt(document.getElementById("numbersUpperBound").value)
    let lowerBound = parseInt(document.getElementById("numbersLowerBound").value)

    // #region core algo
    function reset() {
      stopSort()
      secondNumberObjects = []
      currentIndex = -1
      secondIndex = -1
      upperBound = parseInt(document.getElementById("numbersUpperBound").value)
      lowerBound = parseInt(document.getElementById("numbersLowerBound").value)
      generateNumbers(numbersOfNumber)
      // selectionTime.textContent = 0
    }

    function stopSort() {
      stopFlag = true
      // delay(delayMs - 1).then(() => stopFlag = false)
    }

    async function updateUseTimeLabel(label) {
      await delay(10)
      let t = (((parseFloat(label.textContent) * 100) + 1) / 100).toString()
      // if (t.length > 3) t = t.slice(0, -2) + t.slice
      t = /.*\..?.?.?|^[0-9]*/.exec(t)[0]
      label.textContent = t
      if (stopFlag) return
      updateUseTimeLabel(label)
    }

    function generateNumbers(count) {
      numbers = []
      for (let i = 0; i < count; i++) {
        let randomNumber = Math.floor(Math.random() * (upperBound - lowerBound)) + lowerBound + 1; // 生成 1 到 100 之間的數字
        numbers.push(randomNumber);
      }
    }

    function pushShift() {
      numbers.push(numbers.shift())
    }

    async function swap(i, j) {
      currentIndex = i
      secondIndex = j
      await delay()
      const t = numbers[i]
      numbers[i] = numbers[j]
      numbers[j] = t
    }
    // #endregion

    // #region bubble sort
    function startBubbleSort() {
      bubbleTime.textContent = 0
      stopFlag = false
      updateUseTimeLabel(bubbleTime)
      bubbleSort()
    }

    async function bubbleSort(j = 0) {
      let haveSort = false

      for (let i = 0; i < numbers.length - j; i++) {
        if (stopFlag) return
        currentIndex = i
        if (numbers[i + 1] < numbers[i]) {
          const temp = numbers[i + 1]
          numbers[i + 1] = numbers[i]
          numbers[i] = temp
          haveSort = true
        }
        await delay(delayMs)
      }
      // await delay(30)
      if (haveSort) return bubbleSort(j + 1)
      stopFlag = true
    }
    // #endregion

    // #region selection sort
    function startSelectionSort() {
      selectionTime.textContent = 0
      stopFlag = false
      updateUseTimeLabel(selectionTime)
      selectionSort()
    }

    async function selectionSort(i = 0) {
      let lower = i

      for (let j = i; j < numbers.length; j++) {
        if (stopFlag) return
        currentIndex = j
        if (numbers[j] < numbers[lower]) lower = j
        secondIndex = lower
        await delay(delayMs)
      }
      const temp = numbers[i]
      numbers[i] = numbers[lower]
      numbers[lower] = temp


      if (i == numbers.length - 1) return stopFlag = true
      selectionSort(i + 1)
    }

    function startInsertionSort() {
      insertionTime.textContent = 0
      stopFlag = false
      updateUseTimeLabel(insertionTime)
      insertionSort()
    }
    // #endregion

    // #region insertion sort
    async function insertionSort() {
      for (let i = 1; i < numbers.length + 1; i++) {
        for (let j = i - 1; j >= 1; j--) {
          if (stopFlag) return
          currentIndex = i
          secondIndex = j

          if (numbers[j] > numbers[j - 1]) {
            break
          }
          console.log(numbers)
          const temp = numbers[j - 1]
          numbers[j - 1] = numbers[j]
          numbers[j] = temp
          await delay(delayMs)
        }
      }
      return stopFlag = true
    }
    // #endregion

    // #region merge sort with anima
    async function startMergeSortWithAnima() {
      mergeTime.textContent = 0
      mergeCombineIndex = 0
      stopFlag = false
      updateUseTimeLabel(mergeTime)
      // numbers = await mergeSort(numbers)
      const numberObjArr = []
      numbers.forEach((v, i) => {
        numberObjArr.push({
          v,
          i
        })
      })
      const res = await mergeSort(numberObjArr)
      // res.forEach((e, i) => {
      //   numbers[i] = e.v
      // })
      console.log(numbers)
      return stopFlag = true
    }

    async function mergeSort(arr) {
      if (stopFlag) return

      if (arr.length > 2) {
        return await mergeSortCombine(await mergeSort(arr.slice(0, arr.length / 2)), await mergeSort(arr.slice(arr.length / 2), arr.length))
      } else if (arr.length == 2) return await mergeSortSwap(arr)
      return arr
    }

    async function mergeSortSwap(arr) {
      // anima
      if (stopFlag) return
      currentIndex = arr[0].i
      secondIndex = arr[1].i
      await delay(delayMs)
      if (arr[1].v < arr[0].v) {
        const t = numbers[arr[0].i]
        numbers[arr[0].i] = numbers[arr[1].i]
        numbers[arr[1].i] = t
      }

      // algo
      if (arr[1].v < arr[0].v) return [arr[1], arr[0]]
      return arr
    }

    async function mergeSortCombine(main, add) {
      if (stopFlag) return

      let merged = [];
      while (main.length > 0 || add.length > 0) {
        // algo
        if (main.length > 0 && add.length <= 0) {
          merged.push(main.shift())
        } else if (add.length > 0 && main.length <= 0) {
          merged.push(add.shift())
        } else if (main[0].v < add[0].v) {
          merged.push(main.shift())
        } else {
          merged.push(add.shift())
        }
        // if (j >= add.length main[i].v < add[j].v) {
        //   merged.push(main[i])
        //   i++
        // } else {
        //   merged.push(add[j])
        //   j++
        // }
      }
      // console.log(merged)

      // anima
      mergeCombineIndex = merged[0].i
      for (const e of merged) {
        mergeCombineIndex = Math.min(mergeCombineIndex, e.i)
      }
      for (let i = 0; i < merged.length; i++) {
        numbers[i + mergeCombineIndex] = merged[i].v
        await delay(delayMs)
      }
      // mergeCombineSize = Math.max(merged.length, mergeCombineSize)


      return merged
    }
    // #endregion

    // #region quick sort inplace
    async function startQuickSortInplace() {
      stopFlag = false
      quickInplaceTime.textContent = 0
      updateUseTimeLabel(quickInplaceTime)

      quickSortInplace(numbers, 0, numbers.length - 1).then(e => {
        thirdIndex = -1
        return stopFlag = true
      })
    }

    async function quickSortInplace(arr, left, right) {
      if (stopFlag) return
      if (right > left) {
        const newPivot = await partition(arr, left, right, right)
        await quickSortInplace(arr, left, newPivot - 1)
        await quickSortInplace(arr, newPivot + 1, right)
      }
    }

    async function partition(arr, left, right, pivot) {
      let pivotVlaue = arr[pivot]
      await swap(pivot, right)
      thirdIndex = pivot

      let storeIndex = left
      for (let i = left; i < right; i++) {
        if (stopFlag) return storeIndex
        if (numbers[i] < pivotVlaue) {
          await swap(storeIndex, i)
          // const t = numbers[storeIndex]
          // numbers[storeIndex] = numbers[i]
          // numbers[i] = t
          storeIndex++
        }
      }

      await swap(storeIndex, right)

      return storeIndex
    }
    // #endregion

    // #region counting sort
    async function startCountingSort() {
      stopFlag = false
      countingTime.textContent = 0
      updateUseTimeLabel(countingTime)
      // secondNumberObjects = [{}]
      // for (let i = 0; i < 100; i++) {
      //   secondNumberObjects.push({
      //     count: 0,
      //     value: i + 1,
      //     color: "#969696"
      //   })
      //   await delay()
      // }

      await countingSort(numbers)
    }

    async function countingSort(arr) {
      const counting = []
      for (let i = 0; i < arr.length; i++) {
        if (stopFlag) return
        currentIndex = i
        if (!secondNumberObjects[arr[i]]) {
          for (let j = secondNumberObjects.length; j < arr[i] - 1; j++) {
            if (stopFlag) return
            secondNumberObjects.push({
              count: 0,
              value: j + 1,
              color: "#969696"
            })
            await delay()
          }
          secondNumberObjects[arr[i]] = {
            count: 1,
            value: arr[i],
            color: "skyblue"
          }
        } else {
          secondNumberObjects[arr[i]].count++
          secondNumberObjects[arr[i]].color = "skyblue"
        }
        if (!counting[arr[i]]) {
          counting[arr[i]] = {
            count: 1
          }
        } else {
          counting[arr[i]].count++
        }
        await delay()
      }

      currentIndex = -1
      let countingIndex = 0
      while (counting.length > 0) {
        if (stopFlag) return
        const t = counting.shift()

        if (t && t.count > 0) {
          secondNumberObjects[countingIndex].color = "red"
          for (let i = 0; i < t.count; i++) {
            if (stopFlag) return

            secondNumberObjects[countingIndex].count--
            // t.count--
            arr.shift()
            arr.push(countingIndex)
            await delay()
          }
        }
        countingIndex++
      }
      return stopFlag = true
    }
    // #endregion

    ////
    //// Animation part.
    ////
    const div = document.getElementById('sortingDiv')
    let canvas
    let ctx

    function drawBars() {
      // 設置畫布背景
      ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除畫布

      if (secondNumberObjects.length != 0) {
        ctx.fillStyle = '#ededed';
        ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
        for (let i = 0; i < secondNumberObjects.length; i++) {
          drawSecondBar(i)
        }
      }

      for (let i = 0; i < numbers.length; i++) {
        drawBar(i)
      }
    }

    function drawSecondBar(index) {
      const numberObject = secondNumberObjects[index] ? secondNumberObjects[index] : {
        count: 0,
        value: index,
        color: "#969696"
      }

      const barWidth = canvas.width / secondNumberObjects.length; // 每個長條的寬度
      const barHeight = (((canvas.height - 30) * countingNumbersPercent(numberObject.value)) / 2)

      ctx.fillStyle = numberObject.color
      ctx.fillRect(index * barWidth, canvas.height / 2 - barHeight, barWidth - 2, barHeight)

      ctx.fillStyle = 'black';
      ctx.fillText(numberObject.count, index * barWidth + barWidth / 40, (canvas.height / 2 - barHeight / 2));

      ctx.fillStyle = 'black';
      ctx.fillText(numberObject.value, index * barWidth + barWidth / 40, (canvas.height / 2 - barHeight) - 10);
    }

    function drawBar(index) {
      const barWidth = canvas.width / numbers.length; // 每個長條的寬度
      const barHeight = secondNumberObjects.length == 0 ?
        (canvas.height - 40) * countingNumbersPercent(numbers[index]) :
        (((canvas.height - 40) * countingNumbersPercent(numbers[index])) / 2)

      index == secondIndex ? ctx.fillStyle = "lightgreen" :
        index == currentIndex ? ctx.fillStyle = "red" :
        index == thirdIndex ? ctx.fillStyle = "lightyellow" :
        ctx.fillStyle = 'skyblue';
      ctx.fillRect(index * barWidth, canvas.height - barHeight, barWidth - 2, barHeight);

      ctx.fillStyle = 'black';
      ctx.fillText(numbers[index], index * barWidth + barWidth / 40, canvas.height - barHeight - 10);
    }

    function countingNumbersPercent(number) {
      return (number - lowerBound) / (upperBound - lowerBound)
    }

    function updateVariable() {
      canvas.width = div.offsetWidth;
      canvas.height = div.offsetHeight;
      delayMs = parseInt(document.getElementById("delay").value)
      numbersOfNumber = parseInt(document.getElementById("numbersOfNumber").value)
      // bubbleTime.textContent = (parseInt(bubbleTime.textContent) + 1).toString()
    }

    function init() {
      document.getElementById("pushShiftBtn").addEventListener("click", pushShift)
      document.getElementById("bubbleSortBtn").addEventListener("click", startBubbleSort)
      document.getElementById("selectionSortBtn").addEventListener("click", startSelectionSort)
      document.getElementById("insertionSortBtn").addEventListener("click", startInsertionSort)
      document.getElementById("mergeSortBtn").addEventListener("click", startMergeSortWithAnima)
      document.getElementById("quickSortInplaceBtn").addEventListener("click", startQuickSortInplace)
      document.getElementById("countingSortBtn").addEventListener("click", startCountingSort)
      document.getElementById("resetBtn").addEventListener("click", reset)
      canvas = document.getElementById('sortingCanvas');
      bubbleTime = document.getElementById("bubbleTime")
      selectionTime = document.getElementById("selectionTime")
      insertionTime = document.getElementById("insertionTime")
      mergeTime = document.getElementById("mergeTime")
      quickInplaceTime = document.getElementById("quickInplaceTime")
      countingTime = document.getElementById("countingTime")

      canvas.width = div.offsetWidth;
      canvas.height = div.offsetHeight;

      ctx = canvas.getContext('2d');
      generateNumbers(numbersOfNumber); // 生成隨機數字
      drawBars(); // 繪製長條圖
      window.requestAnimationFrame(loop);
    }

    window.onload = init; // 頁面加載後執行初始化

    window.requestAnimationFrame =
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback) {
        window.setTimeout(callback, 1000 / 40);
      };

    function loop() {
      updateVariable()
      drawBars();
      window.requestAnimationFrame(loop);
    }

    const delay = (ms = delayMs) => new Promise(resolve => setTimeout(resolve, ms));
  </script>
</body>

</html>